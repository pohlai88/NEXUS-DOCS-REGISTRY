// @aibos/docs-registry — Audit Functions
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// AUTHORITY: SRS-DOCSREG-001 §3.4, ADR-DOCSREG-001 ADR-008
// PURPOSE: Audit document integrity — schema, checksum, orphans
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

import fs from "node:fs";
import path from "node:path";
import type {
  AuditResult,
  DocsRegistryConfig,
  Violation,
} from "../types/index.js";
import { computeChecksum } from "./checksum.js";
import { discoverDocs } from "./discovery.js";

/**
 * Audit all: schema, checksum, orphans.
 *
 * Returns structured result (never throws for violations per ADR-008).
 */
export async function auditAll(
  config: DocsRegistryConfig
): Promise<AuditResult> {
  const results = await Promise.all([
    auditChecksum(config),
    auditOrphans(config),
  ]);

  const violations = results.flatMap((r) => r.violations);
  return {
    passed: violations.length === 0,
    violations,
  };
}

/**
 * Audit checksums — computed vs stored.
 */
export async function auditChecksum(
  config: DocsRegistryConfig
): Promise<AuditResult> {
  const docs = await discoverDocs(config.docsDir);
  const violations: Violation[] = [];

  for (const doc of docs) {
    if (!fs.existsSync(doc.docMdPath)) {
      violations.push({
        type: "MISSING_DOC",
        docId: doc.docId,
        message: `doc.md not found for ${doc.docId}`,
        path: doc.docMdPath,
      });
      continue;
    }

    const content = fs.readFileSync(doc.docMdPath, "utf8");
    const computed = computeChecksum(content, config.checksumAlgorithm);
    const stored = doc.docJson.checksum_sha256;

    if (stored && computed !== stored) {
      violations.push({
        type: "CHECKSUM_MISMATCH",
        docId: doc.docId,
        message: `Checksum mismatch: stored=${stored.slice(
          0,
          16
        )}... computed=${computed.slice(0, 16)}...`,
        path: doc.docMdPath,
      });
    }
  }

  return { passed: violations.length === 0, violations };
}

/**
 * Audit INDEX.md consistency.
 *
 * Checks that INDEX.md matches what would be generated.
 */
export async function auditIndex(
  config: DocsRegistryConfig
): Promise<AuditResult> {
  const indexPath = path.join(config.docsDir, "INDEX.md");

  if (!fs.existsSync(indexPath)) {
    return {
      passed: false,
      violations: [
        {
          type: "MISSING_DOC",
          docId: "INDEX",
          message: "INDEX.md does not exist",
          path: indexPath,
        },
      ],
    };
  }

  // Generate expected INDEX content
  const docs = await discoverDocs(config.docsDir);
  const rows = docs.map((doc) => {
    const relPath = path
      .relative(config.docsDir, doc.docMdPath)
      .replace(/\\/g, "/");
    const checksum = doc.docJson.checksum_sha256
      ? `\`${doc.docJson.checksum_sha256.slice(0, 16)}...\``
      : "`—`";

    return `| ${doc.docJson.document_id} | ${doc.docJson.title} | v${doc.docJson.version} | ${doc.docJson.status} | ${doc.docJson.authority} | ${checksum} | ${relPath} |`;
  });

  const expectedIndex = [
    "# Document Index (Generated)",
    "",
    "> DO NOT hand-edit. Generated by `@aibos/docs-registry`.",
    "",
    "| Doc ID | Title | Version | Status | Authority | Checksum | Path |",
    "|--------|-------|--------:|--------|-----------|----------|------|",
    ...rows,
    "",
  ].join("\n");

  const currentIndex = fs.readFileSync(indexPath, "utf8");

  if (currentIndex !== expectedIndex) {
    return {
      passed: false,
      violations: [
        {
          type: "PHANTOM_DOC",
          docId: "INDEX",
          message: "INDEX.md differs from expected. Run `pnpm gen` to fix.",
          path: indexPath,
        },
      ],
    };
  }

  return { passed: true, violations: [] };
}

/**
 * Audit for orphan/phantom documents.
 *
 * Checks:
 * - PHANTOM: in INDEX but not on filesystem
 * - MISSING: on filesystem but not in INDEX
 */
export async function auditOrphans(
  config: DocsRegistryConfig
): Promise<AuditResult> {
  const indexPath = path.join(config.docsDir, "INDEX.md");
  const violations: Violation[] = [];

  if (!fs.existsSync(indexPath)) {
    // No INDEX to check — not a violation, just nothing to audit
    return { passed: true, violations: [] };
  }

  const indexContent = fs.readFileSync(indexPath, "utf8");
  const docs = await discoverDocs(config.docsDir);

  // Extract doc IDs from INDEX
  const indexDocIds = new Set<string>();
  const rowPattern = /^\| ([A-Z]+-[A-Z0-9]+-\d{3}) \|/gm;
  let match;
  while ((match = rowPattern.exec(indexContent)) !== null) {
    indexDocIds.add(match[1]);
  }

  // Filesystem doc IDs
  const fsDocIds = new Set(docs.map((d) => d.docId));

  // Phantom: in INDEX but not filesystem
  for (const indexId of indexDocIds) {
    if (!fsDocIds.has(indexId)) {
      violations.push({
        type: "PHANTOM_DOC",
        docId: indexId,
        message: `Document ${indexId} in INDEX.md but not on filesystem`,
        path: indexPath,
      });
    }
  }

  // Missing: in filesystem but not INDEX
  for (const fsId of fsDocIds) {
    if (!indexDocIds.has(fsId)) {
      violations.push({
        type: "MISSING_DOC",
        docId: fsId,
        message: `Document ${fsId} on filesystem but not in INDEX.md`,
        path: path.join(config.docsDir, "**", fsId),
      });
    }
  }

  return { passed: violations.length === 0, violations };
}
